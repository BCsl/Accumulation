当前使用`Intent.FLAG_ACTIVITY_NEW_TASK|Intent.FLAG_ACTIVITY_CLEAR_TASK`启动一个`Activity`的时候，其`ActivityRecord`已经存在的情况下，会调用`TaskRecord#performClearTaskLocked`方法来清空栈

```java
TaskRecord.java

final void performClearTaskLocked() {
    performClearTaskAtIndexLocked(0);
}

final void performClearTaskAtIndexLocked(int activityNdx) {
    int numActivities = mActivities.size();
    for ( ; activityNdx < numActivities; ++activityNdx) {
        final ActivityRecord r = mActivities.get(activityNdx);
        if (r.finishing) {
            continue;
        }
        if (stack.finishActivityLocked(r, Activity.RESULT_CANCELED, null, "clear", false)) {
            --activityNdx;
            --numActivities;
        }
    }
}
```

对于使用`Intent.FLAG_ACTIVITY_CLEAR_TOP`、`ActivityInfo.LAUNCH_SINGLE_TASK`或`ActivityInfo.LAUNCH_SINGLE_INSTANCE`

启动Activity对应的`ActivityRecord`以上的Activity都会被finish掉，并返回该`ActivityRecord`实例，如果当前实例是默认模式，那么当前的实例也会finish，并返回NULL

```java
final ActivityRecord performClearTaskLocked(ActivityRecord newR, int launchFlags) {
    int numActivities = mActivities.size();
    for (int activityNdx = numActivities - 1; activityNdx >= 0; --activityNdx) {
        ActivityRecord r = mActivities.get(activityNdx);
        if (r.finishing) {
            continue;
        }
        if (r.realActivity.equals(newR.realActivity)) {
            // Here it is!  Now finish everything in front...
            final ActivityRecord ret = r;

            for (++activityNdx; activityNdx < numActivities; ++activityNdx) {
                r = mActivities.get(activityNdx);
                if (r.finishing) {
                    continue;
                }
                ActivityOptions opts = r.takeOptionsLocked();
                if (opts != null) {
                    ret.updateOptionsLocked(opts);
                }
                if (stack.finishActivityLocked(r, Activity.RESULT_CANCELED, null, "clear",false)) {
                    --activityNdx;
                    --numActivities;
                }
            }
            // Finally, if this is a normal launch mode (that is, not
            // expecting onNewIntent()), then we will finish the current
            // instance of the activity so a new fresh one can be started.
            // 标准模式即LAUNCH_MULTIPLE
            if (ret.launchMode == ActivityInfo.LAUNCH_MULTIPLE&& (launchFlags & Intent.FLAG_ACTIVITY_SINGLE_TOP) == 0) {
                if (!ret.finishing) {
                    stack.finishActivityLocked(ret, Activity.RESULT_CANCELED, null,"clear", false);
                    return null;
                }
            }

            return ret;
        }
    }

    return null;
}
```
