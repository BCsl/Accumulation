## volatile 变量
>保证了变量的可见性，但不提供原子性保证[了解更多](http://www.blogjava.net/bolo/archive/2014/06/20/414971.html)

特征：
* 1.可见性：对一个Volatile变量进行读操作，必能看到任意线程对这个Volatile变量的最后的写入(happen-before关系)。
* 2.~~原子性：对与任意单个Volatile变量的读写具有原子性。但类似Volatile++这些复合操作不具有原子性~~（变量读写的原子性是JVM规范定义的，不是volatile这个关键字；另外，Java对于double这种数据，读写都不是原子的；细节可以参考Effective Java并发那一章）

#### volatile读写的内存语义
* 写一个`volatile`变量时，`JMM`会把该线程对应的本地内存中的共享变量值刷新到主内存
* 当读一个`volatile`变量时，`JMM`会把该线程对应的本地内存置为无效。线程接下来将从主内存中读取共享变量。

#### volatile读写的内存语义的实现
重排序规则：

| 第一\二个操作 | 普通读/写 | volatile读 | volatile写 |
|-----------|----------|------------|------------|
| 普通读/写  |          |            |    NO      |
| volatile读 |  NO      |    NO     |     NO       |
| volatile写 |          |    NO     |     NO       |

* 当第二个操作为volatile写的时候，都不允许重排序，保证写之前的操作不被重排序到volatile写之后
* 当第一个操作为volatile读的时候，都不允许重排序，保证读之后的操作不被重排序到volatile读之后
* 当第一个操作为volatile写，第二个操作是volatile读的时候，不允许重排序，不能重排序Android广播机制-发送和处理1


基于保守策略的JMM内存屏障插入策略：
* 在每个`volatile`写操作的前面插入一个`StoreStore`屏障
* 在每个`volatile`写操作的后面插入一个`StoreLoad`屏障
* 在每个`volatile`读操作的后面插入一个`LoadLoad`屏障
* 在每个`volatile`读操作的后面插入一个`LoadStore`屏障

## 锁
锁是java并发编程中最重要的同步机制

#### 锁的内存语义
* 线程A释放一个锁，实质上是线程A向接下来将要获取这个锁的某个线程发出了（线程A对共享变量作出了改变）消息
* 实质上是线程B接收了之前某个线程发出的（在释放这个锁之前对共享变量所做修改的）消息
* 线程A释放锁，随后线程B获取这个锁，这个过程实质上是线程A通过主内存向线程B发送消息

#### 锁的内存语义的实现
##### 公平锁
公平锁是通过`volatile`实现同步的。公平锁在释放锁的最后写`volatile`变量`state`；在获取锁时首先读这个`volatile`变量。根据`volatile`的`happens-before`规则，释放锁的线程在写`volatile`变量之前可见的共享变量，在获取锁的线程读取同一个`volatile`变量后将立即变的对获取锁的线程可见

## final
* `final`写：构造函数内对一个final域的写入，与随后把这个被构造对象的引用赋值给一个引用变量，这两个操作之间不能重排序
* `final`读：初次读一个包含final域的对象的引用，与随后初次读对象的final域，这两个操作之间不能重排序

#### 写final域的重排序规则
* JMM禁止把final域的写重排序到构造函数之外
* 编译器会在final域写之后，构造函数return之前，插入一个`StoreStore`屏障。这个屏障可以禁止把final域的写重排序到构造函数之外

保证了该对象的对其他线程引用的可见之前，对象的final域已经正确初始化了，而普通域不具备这个保证

#### 读final域的重排序规则
* 一个线程中初次读对象的引用与初次读该对象的final域，JMM禁止处理器重排序两个操作（仅仅针对处理器），编译器在读final域的前面插入`LoadLoad`屏障

保证了读一个对象的final域之前一定读了包含该final域的对象的引用（初始化）

这些规则其实都是为了保证`final`域能正确的初始化并被读取，而普通变量则没这样的保证

#### final域是引用类型
增加如下约束
* 在构造函数内对一个final引用的对象的成员域的写入，与随后在构造函数外把这个被构造对象的引用赋值给一个引用变量，这两个操作之间不能重排序

确保了final引用对象的成员的初始化

#### 逸出
写final域的重排序规则可以确保：在引用变量为任意线程可见之前，该引用变量指向的对象的final域已经在构造函数中被正确初始化过了。其实要得到这个效果，还需要一个保证：在构造函数内部，不能让这个被构造对象的引用为其他线程可见，也就是对象引用不能在构造函数中“逸出”（如:通过this赋值到其他引用，可能会被重排序到，final域写之前）
#### 处理器上的实现
在final域的写之后，构造函数return之前，插入一个`StoreStore`障屏。在读`final`域的操作前面插入一个`LoadLoad`屏障，但在一些处理器（X86）上并不会插入这些内存屏障！
