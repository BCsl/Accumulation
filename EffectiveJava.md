## 创建和销毁对象
### 1.使用静态工厂方法替代创建对象
#### 优点
* 有清晰的名字名称（易读性）
* 不必每次创建新的对象(类似FlyWeight模式，Boolean类的使用)
```java
   public static final Boolean TRUE = new Boolean(true);

   public static final Boolean FALSE = new Boolean(false);
   ...
   public static Boolean valueOf(boolean b) {
      return b ? Boolean.TRUE : Boolean.FALSE;
    }
```
* 可以返回原返回类型的任何子类型（灵活性）
使用场景为Fragment提供newInstance的静态方法。。

### 2.遇到多个构造参数的时候考虑使用构建器（Builder）
#### 使用场景
构造器需要多个参数，但并不是每个都必须的情况下，解决的方式可能有
* 多个构造器（难以阅读）
* 使用setter模式（相对清晰，但很难保证状态的一致，且难以调试，并阻止该对象成为不可变类）
* Bulider模式，易于阅读，与setter不同，在调用构建者的build方法返回特定类型的对象的时候可以进行状态的检查，对参数进行约束，并可以使对象成为不可变类。

### 3.使用私有构造器或枚举类型强化Singleton属性
  使用私有构造器可以保证单例的全局唯一，一般使用工厂方法模式返回单例，__但是还是可以通过反射来创建新的实例__，并在序列化（比较少用）的时候，除了继承Serializalbe接口，为了
  保证单例的属性，其他实例域都需要是transient的，并提供readResolve方法。

### 4.使用私有构造器强化不可实例化的能力
  工具类咯。。

### 5.避免创建不必要对象
  常见的基本类型常量池，和对于提供静态工厂方法和构造器的不可变对象（如Bollean），使用静态工厂方法。还可以重用明知道不会被修改的可变对象。

### 6.消除过期的引用（内存溢出）
  时刻关心代码是否会造成内存泄漏！一般来说很隐蔽。但只要一个引用已经过期（什么时候过期也是需要考虑的问题），及时清除即可。还有就是善用java.lang.ref包。
  常见场景：1.缓存，使用弱引用解决。2.监听器和其他回调，很好的解决方式是使用弱引用（例如android中的context，如果其他对象需要保存这个context，应该保存的是context的弱引用）

### 7.避免使用终结方法
  不要依赖finalize，一般也没人用。呵呵。
  以下参考子【JAVA编程思想】：JAVA中，__垃圾回收只与内存有关__,所以与垃圾回收相关的`finalize`方法也应该与内存及其释放相关，但无论对象是以如何创建，垃圾回收器总是负责释放对象占用的内存（1.不等于析构，2.可能不会释放，一般在内存吃紧的时候进行垃圾回收），所以`finalize`用于对某种非创建对象的方式分配内存进行释放。如本地方法中使用`c++`的`new`创建对象，需要`delete`来释放。

## 所有对象都通用的方法(Object中所有非final的public方法都有自己的通用约定)

### 8.覆盖equals时请遵守通用约定
  如果覆盖了，要保持equal实现的等价关系：自反性（非空a,a.equeal(a)为true）；对称性（非空a,b,a.equal(b)为true,则b.queal(a)为true）；传递性；一致性（只要对象信息不变，多次调用结果要一样）。

### 9.覆盖equals时总要覆盖hasCode
### 10.始终要覆盖toString
  可以简洁明了打log(￣▽￣)，有固定格式更好
### 11.谨慎覆盖clone
  这也是

### 12.考虑实现comparable接口
  一般需要对对象进行对比的时候才用吧（小心加减法时候可能会溢出哦）

## 类和接口
### 13.使类和成员的可访问性最小化

### 14.在公有类使用公用方法而不是公有域

### 15.使可变性最小

### 16.复合优于继承
  父类如果有一天改变了，因为子类受制于父类，这就打破了封装性，策略模式，使用复合的模式有装饰者模式和代理模式。不是绝对的喔。
### 17.接口优于抽象
### 22.优先使用静态成员类（使用嵌套类的时候）
  嵌套类的目的只是为外围类提供服务。4中类型的嵌套类1，静态成员类，2，非静态成员类，3，本地类（代码块中声明，用得比较少），4，匿名内部类，除了1，其他叫内部类。
  静态成员类不会隐含外围类的this指针！且对外围类之外其他类可见。因为静态成员类不隐含外围类this指针，__降低了内存泄漏风险__（Handler要使用构造成静态成员类的方式来使用，并内部保存context的弱引用）
  而非静态成员类最普遍的是Android中的Adapter的实现。

## 方法
### 38.检查参数的有效性
  编写方法和构造器时，要考虑参数的限制。要写在文档中并在方法体开头进行检查限制（断言，抛异常等方式）。养成这样的习惯很重要。

### 39.必要时进行保护性拷贝
  考虑下对于一个不可变类，有一个可变类的成员变量并通过构造器传递赋值，这样就使得不可变类就变得不安全了，所以需要进行保护性拷贝，也就是使用备份对象，而不是原始对象。同时对位提供该可变对象的接口的时候，
  也需要谨慎，使用保护性拷贝。__注意：使用保护性拷贝并不一定只是使用在不可变类__，当一个类接收一个对象进入内部结构的时候，都需要考虑，当前对象是否可以接受该对象的改变。
## 并发
### 71.慎用延迟初始化
## 序列化
